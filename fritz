#!/usr/bin/env python
import argparse
import datetime
import json
import os
from pathlib import Path
import requests
import subprocess
import sys
import time
import yaml

from tools.check_environment import deps_ok

sys.path.insert(0, "skyportal")

SKYPORTAL_CONFIG = "skyportal/config.yaml.defaults"
KOWALSKI_CONFIG = "kowalski/config.defaults.yaml"


def generate_kowalski_token(
    user_id, jwt_secret, jwt_algorithm="HS256", jwt_exp_delta_seconds=30 * 86400 * 12
):
    """
    Generate a token for SkyPortal to access Kowalski
    """
    import jwt

    jwt_config = {
        "user_id": user_id,
        "JWT_SECRET": jwt_secret,
        "JWT_ALGORITHM": jwt_algorithm,
        "JWT_EXP_DELTA_SECONDS": jwt_exp_delta_seconds,
    }

    payload = {
        "user_id": jwt_config["user_id"],
        "exp": datetime.datetime.utcnow()
        + datetime.timedelta(seconds=jwt_config["JWT_EXP_DELTA_SECONDS"]),
    }
    jwt_token = jwt.encode(
        payload, jwt_config["JWT_SECRET"], jwt_config["JWT_ALGORITHM"]
    )

    return jwt_token


def get_skyportal_token():
    """
    Get admin token for Kowalski to access SkyPortal
    """
    result = subprocess.run(
        [
            "docker",
            "exec",
            "-i",
            "skyportal_web_1",
            "/bin/bash",
            "-c",
            "cat /skyportal/.tokens.yaml",
        ],
        cwd="skyportal",
        capture_output=True,
        universal_newlines=True,
    )
    token = result.stdout.split()[-1]

    if len(token) != 36:
        raise RuntimeError("Failed to get a SkyPortal token for Kowalski")

    return token


def skyportal_api(method, endpoint, token, data=None):
    headers = {"Authorization": f"token {token}"}
    response = requests.request(method, endpoint, json=data, headers=headers)
    return response


def merge_kowalski_and_skyportal_configs():
    """
    Check if config exists, generate a K token for SP, adjust cfg and distribute to K and SP
    """

    config = {}

    # generate a token for SkyPortal to talk to Kowalski
    with open(SKYPORTAL_CONFIG) as config_yaml:
        config["skyportal"] = yaml.load(config_yaml, Loader=yaml.FullLoader)

    with open(KOWALSKI_CONFIG) as config_yaml:
        kowalski_config = yaml.load(config_yaml, Loader=yaml.FullLoader)
        config.update(kowalski_config)

    kowalski_token = generate_kowalski_token(
        user_id=config["kowalski"]["server"]["admin_username"],
        jwt_secret=config["kowalski"]["server"]["JWT_SECRET_KEY"],
        jwt_algorithm=config["kowalski"]["server"]["JWT_ALGORITHM"],
        jwt_exp_delta_seconds=int(
            config["kowalski"]["server"]["JWT_EXP_DELTA_SECONDS"]
        ),
    )

    config["skyportal"]["app"]["kowalski"]["token"] = kowalski_token

    # get Docker gateway IP
    command = [
        "docker",
        "network",
        "inspect",
        "bridge",
        '--format={{index .IPAM.Config 0 "Gateway"}}',
    ]
    p = subprocess.run(command, stdout=subprocess.PIPE)
    gateway_ip = p.stdout.decode("utf-8").strip()
    config["kowalski"]["skyportal"]["host"] = gateway_ip

    # strip down, adjust, and copy over to Kowalski and SkyPortal
    config_kowalski = {"kowalski": config["kowalski"]}  # don't need the SP stuff
    with open("kowalski/config.yaml", "w") as config_yaml:
        yaml.dump(config_kowalski, config_yaml)

    # Docker-specific SkyPortal stuff:
    config["skyportal"]["database"]["host"] = "db"
    config["skyportal"]["server"]["url"] = "http://localhost:5000"
    config_skyportal = config["skyportal"]  # don't need the K stuff
    with open("skyportal/config.yaml", "w") as config_yaml:
        yaml.dump(config_skyportal, config_yaml)
    return config


def update(args):
    """
    Update Fritz
    """
    p = subprocess.run(["git", "pull", args.repo, args.branch])
    if p.returncode != 0:
        raise RuntimeError(f"Failed to git pull Fritz from {args.repo}/{args.branch}")

    if args.init:
        # initialize/update fritz's submodules kowalski and skyportal
        # pull skyportal and kowalski
        p = subprocess.run(["git", "submodule", "update", "--init", "--recursive"])
        if p.returncode != 0:
            raise RuntimeError("Failed to initialize fritz's submodules")

    # auto stash SP
    for module in ["kowalski", "skyportal"]:
        p = subprocess.run(["git", "stash"], cwd=module)
        if p.returncode != 0:
            raise RuntimeError(f"{module} autostash failed")

    # update submodules
    p = subprocess.run(["git", "submodule", "update", "--recursive"])
    if p.returncode != 0:
        raise RuntimeError("Failed to update fritz's submodules")

    # octopus merge
    for module in ["kowalski", "skyportal"]:

        # get the branch names
        gb = subprocess.check_output(["git", "branch"], cwd=module).split()
        extensions = list(filter(lambda b: b.startswith("ext/"), gb))

        # do an octopus merge
        if len(extensions) > 0:
            p = subprocess.run(["git", "merge"] + extensions, cwd=module)

        if p.returncode != 0:
            raise RuntimeError(
                f"{module} extension octopus merge did "
                f"not terminate cleanly. Please inspect the repo "
                f"and resolve conflicts."
            )


def build(args):
    """
    Build Fritz
    """

    if not args.dev:
        update(args)

    # check environment
    env_ok = deps_ok()
    if not env_ok:
        raise RuntimeError("Halting because of unsatisfied system dependencies")

    if not args.no_kowalski:
        # install Kowalski's deps:
        c = ["pip", "install", "-r", "requirements.txt"]
        subprocess.run(c, cwd="kowalski", check=True)

    fritz_config = merge_kowalski_and_skyportal_configs()

    # adjust F-specific docker-compose.yaml for SP
    with open("skyportal/docker-compose.yaml") as docker_compose_yaml:
        docker_compose = yaml.load(docker_compose_yaml, Loader=yaml.FullLoader)
    # fix absolute paths in docker-compose.yaml
    for vi, volume in enumerate(docker_compose["services"]["web"]["volumes"]):
        docker_compose["services"]["web"]["volumes"][vi] = volume.replace(
            "${PWD}", str(Path(__file__).parent.absolute())
        )
    if args.traefik:
        # fix host for Traefik
        docker_compose["services"]["web"]["labels"][2] = docker_compose["services"][
            "web"
        ]["labels"][2].replace("<host>", fritz_config["skyportal"]["server"]["host"])
    else:
        # not running behind Traefik? then publish port 5000 on hosts
        port = fritz_config["skyportal"]["server"].get("port", 5000)
        if port is None:
            port = 5000
        docker_compose["services"]["web"]["ports"] = [f"{port}:{port}"]
    # execute `make run` instead of `make run_production` at init:
    if args.init:
        docker_compose["services"]["web"][
            "command"
        ] = 'bash -c "source /skyportal_env/bin/activate && (make log &) && make run"'
    # save the adjusted version
    with open("skyportal/docker-compose.yaml", "w") as docker_compose_yaml:
        yaml.dump(docker_compose, docker_compose_yaml)

    # Build skyportal's images
    cmd = ["docker", "build", "."]
    if args.skyportal_tag:
        cmd.extend(["-t", args.skyportal_tag])
    print(f"Building SkyPortal docker image (tag: {args.skyportal_tag})")
    p = subprocess.run(cmd, cwd="skyportal")
    if p.returncode != 0:
        raise RuntimeError("Failed to build skyportal's docker images")

    # when initializing, must start SP to generate token for K
    if args.init:
        # create common docker network (if it does not exist yet)
        p = subprocess.run(
            ["docker", "network", "create", "fritz_net"],
            capture_output=True,
            universal_newlines=True,
        )
        if (p.returncode != 0) and ("already exists" not in p.stderr):
            raise RuntimeError("Failed to create network fritz_net")

        # start up skyportal
        # docker-compose.yaml bind-mounts the fritz-specific config.yaml and db_seed.yaml
        p = subprocess.run(
            ["docker-compose", "-f", "docker-compose.yaml", "up", "-d"],
            cwd="skyportal",
            check=True,
        )
        if p.returncode != 0:
            raise RuntimeError("Failed to start SkyPortal")

        # init skyportal and load seed data
        mi, max_retires = 1, 3
        while mi <= max_retires:
            p = subprocess.run(
                [
                    "docker",
                    "exec",
                    "-i",
                    "skyportal_web_1",
                    "/bin/bash",
                    "-c",
                    "source /skyportal_env/bin/activate; make db_clear; make db_init;"
                    "make prepare_seed_data; make load_seed_data",
                ],
                cwd="skyportal",
            )
            if p.returncode == 0:
                break
            else:
                print("Failed to load seed data into SkyPortal, waiting to retry...")
                mi += 1
                time.sleep(15)
        if mi == max_retires + 1:
            raise RuntimeError("Failed to init SkyPortal and load seed data")

        # generate a token for Kowalski to talk to SkyPortal:
        with open("kowalski/config.yaml") as cyaml:
            config = yaml.load(cyaml, Loader=yaml.FullLoader)

        token = get_skyportal_token()
        config["kowalski"]["skyportal"]["token"] = token

        # save it to K's config:
        with open("kowalski/config.yaml", "w") as cyaml:
            yaml.dump(config, cyaml)

        # update fritz.yaml
        fritz_config["kowalski"]["skyportal"]["token"] = token
        with open("fritz.yaml", "w") as fritz_config_yaml:
            yaml.dump(fritz_config, fritz_config_yaml)

    if not args.no_kowalski:
        # Build kowalski's images
        c = ["python", "kowalski.py", "build"]
        if args.yes:
            c.append("--yes")
        p = subprocess.run(c, cwd="kowalski")
        if p.returncode != 0:
            raise RuntimeError("Failed to build Kowalski's docker images")

    if args.init:
        # stop SkyPortal
        subprocess.run(
            ["docker-compose", "-f", "docker-compose.yaml", "down"],
            cwd="skyportal",
        )

        # remove common network
        subprocess.run(["docker", "network", "remove", "fritz_net"])


def run(args):
    """
    Launch Fritz
    """

    if args.init:
        build(args=args)

    # create common docker network (if it does not exist yet)
    p = subprocess.run(
        ["docker", "network", "create", "fritz_net"],
        capture_output=True,
        universal_newlines=True,
    )
    if (p.returncode != 0) and ("already exists" not in p.stderr):
        raise RuntimeError("Failed to create network fritz_net")

    # start up skyportal
    # docker-compose.yaml bind-mounts the fritz-specific config.yaml and db_seed.yaml
    p = subprocess.run(
        ["docker-compose", "-f", "docker-compose.yaml", "up", "-d"],
        cwd="skyportal",
        check=True,
    )
    if p.returncode != 0:
        raise RuntimeError("Failed to start SkyPortal")

    # start up kowalski
    c = ["python", "kowalski.py", "up"]
    p = subprocess.run(c, cwd="kowalski")
    if p.returncode != 0:
        raise RuntimeError("Failed to start Kowalski")

    if args.traefik:
        # fire up traefik
        p = subprocess.run(
            ["docker-compose", "-f", "docker-compose.traefik.yaml", "up", "-d"],
            check=True,
            cwd="kowalski",
        )
        if p.returncode != 0:
            raise RuntimeError("Failed to start Traefik")


def stop(args):
    """
    Shut down Fritz
    """
    print("Shutting down Fritz...")

    # stop traefik if it is running
    running_container_images = (
        subprocess.check_output(["docker", "ps", "-a", "--format", "{{.Image}}"])
        .decode("utf-8")
        .strip()
        .split("\n")
    )
    traefik_is_running = any("traefik" in x.lower() for x in running_container_images)
    if traefik_is_running:
        print("Shutting down Traefik")
        subprocess.run(
            ["docker-compose", "-f", "docker-compose.traefik.yaml", "down"],
            cwd="kowalski",
        )

    # stop Kowalski and SkyPortal
    subprocess.run(["python", "kowalski.py", "down"], cwd="kowalski")
    subprocess.run(
        ["docker-compose", "-f", "docker-compose.yaml", "down"],
        cwd="skyportal",
    )

    # remove common network
    subprocess.run(["docker", "network", "remove", "fritz_net"])


def log(args):
    """
    Show colorized logs while the marshal is running
    """
    # p = subprocess.run(["make", "log"], cwd="skyportal")
    p = subprocess.run(
        [
            "docker",
            "exec",
            "-i",
            "skyportal_web_1",
            "/bin/bash",
            "-c",
            "source /skyportal_env/bin/activate; make log",
        ],
        cwd="skyportal",
    )
    if p.returncode != 0:
        raise RuntimeError("Failed to display fritz's logs")


def develop(args=None):
    """
    Install developer tools.
    """
    subprocess.run(["pre-commit", "install"])


def lint(args):
    try:
        import pre_commit  # noqa: F401
    except ImportError:
        develop()

    try:
        subprocess.run(["pre-commit", "run", "--all-files"], check=True)
    except subprocess.CalledProcessError:
        sys.exit(1)


def prune(args):
    """
    Prune fritz's docker containers and volumes and reset configs to defaults
    """
    go = (
        input(
            "Do you want to prune Fritz's docker containers and volumes and deinit submodules? [y/N] "
        )
        if not args.yes
        else "y"
    )

    if go.lower() == "y":
        # try stopping anything that's running first:
        stop(args)

        # remove docker images
        for image_name in ("kowalski_api", "kowalski_ingester", "skyportal/web"):
            p1 = subprocess.Popen(["docker", "images"], stdout=subprocess.PIPE)
            p2 = subprocess.Popen(
                ["grep", image_name], stdin=p1.stdout, stdout=subprocess.PIPE
            )
            image_id = subprocess.check_output(
                ["awk", "{print $3}"], stdin=p2.stdout, universal_newlines=True
            ).strip()
            p3 = subprocess.run(["docker", "rmi", image_id])
            if p3.returncode == 0:
                print(f"Removed {image_name} docker image")
            else:
                print(f"Failed to remove {image_name} docker image")

        # remove docker volumes
        for volume_name in (
            "kowalski_data",
            "kowalski_mongodb",
            "skyportal_dbdata",
            "skyportal_thumbnails",
        ):
            p = subprocess.run(["docker", "volume", "rm", volume_name])
            if p.returncode == 0:
                print(f"Removed {volume_name} docker volume")
            else:
                print(f"Failed to remove {volume_name} docker volume")

        # deinit submodules
        p = subprocess.run(["git", "submodule", "deinit", "--all", "-f"])
        if p.returncode == 0:
            print("Deinitialized fritz's submodules")
        else:
            print("Failed to deinit fritz's submodules")


def test(args):
    print("Running integration testing...")

    # load config
    with open("fritz.yaml") as fritz_config_yaml:
        fritz_config = yaml.load(fritz_config_yaml, Loader=yaml.FullLoader)

    num_retries = 10
    # make sure the containers are up and running
    for i in range(num_retries):
        if i == num_retries - 1:
            raise RuntimeError("Fritz's containers failed to spin up")

        command = ["docker", "ps", "-a"]
        container_list = (
            subprocess.check_output(command, universal_newlines=True)
            .strip()
            .split("\n")
        )
        if len(container_list) == 1:
            print("No containers are running, waiting...")
            time.sleep(3)
            continue

        containers_up = (
            len(
                [
                    container
                    for container in container_list
                    if container_name in container and " Up " in container
                ]
            )
            > 0
            for container_name in (
                "kowalski_ingester_1",
                "kowalski_api_1",
                "skyportal_web_1",
            )
        )

        if not all(containers_up):
            print("Fritz's containers are not up, waiting...")
            time.sleep(3)
            continue

        break

    # make sure SkyPortal is running
    for i in range(num_retries):
        if i == num_retries - 1:
            raise RuntimeError("SkyPortal failed to spin up")

        command = ["docker", "exec", "-i", "skyportal_web_1", "ps", "-ef"]
        process_list = subprocess.check_output(command, universal_newlines=True).strip()

        if "app.py" not in process_list:
            print("SkyPortal is not up, waiting...")
            time.sleep(10)
            continue

        break

    # ensure that the SkyPortal app is responding to requests
    url = (
        f"{fritz_config['kowalski']['skyportal']['protocol']}://"
        f"{fritz_config['kowalski']['skyportal']['host']}:{fritz_config['kowalski']['skyportal']['port']}"
        "/api/sysinfo"
    )
    token = fritz_config["kowalski"]["skyportal"]["token"]
    for i in range(num_retries):
        if i == num_retries - 1:
            raise RuntimeError("SkyPortal failed to spin up")
        try:
            response = skyportal_api("GET", endpoint=url, token=token)

            if response.status_code != 200:
                print("SkyPortal is not responding, waiting...")
                time.sleep(10)
            else:
                break

        except requests.exceptions.ConnectionError:
            print("SkyPortal is not responding, waiting...")
            time.sleep(10)
            continue

    print("Testing ZTF alert stream consumption and digestion")

    command = [
        "docker",
        "exec",
        "-i",
        "kowalski_ingester_1",
        "python",
        "-m",
        "pytest",
        "-s",
        "test_ingester.py",
    ]
    try:
        subprocess.run(command, check=True)
    except subprocess.CalledProcessError:
        sys.exit(1)

    # show processing log from dask cluster
    command = [
        "docker",
        "exec",
        "-i",
        "kowalski_ingester_1",
        "cat",
        "/data/logs/dask_cluster.log",
    ]
    try:
        subprocess.run(command, check=True)
    except subprocess.CalledProcessError:
        sys.exit(1)

    print("Testing Fritz-specific SkyPortal extensions")

    # use the generated config as test config for e.g. the correct db connection details
    command = [
        "docker",
        "exec",
        "-i",
        "skyportal_web_1",
        "cp",
        "config.yaml",
        "test_config.yaml",
    ]
    try:
        subprocess.run(command, check=True)
    except subprocess.CalledProcessError:
        sys.exit(1)

    api_tests = [
        test_file.name
        for test_file in Path("extensions/skyportal/skyportal/tests/api").glob(
            "test_*.py"
        )
    ]

    for api_test in api_tests:
        command = [
            "docker",
            "exec",
            "-i",
            "skyportal_web_1",
            "/bin/bash",
            "-c",
            "source /skyportal_env/bin/activate &&"
            f"python -m pytest -s skyportal/tests/api/{api_test}",
        ]
        try:
            subprocess.run(command, check=True)
        except subprocess.CalledProcessError:
            continue


def doc(args):
    for destination in ("config.yaml.defaults",):
        subprocess.run(
            [
                "cp",
                "config.yaml",
                destination,
            ],
            check=True,
            cwd="skyportal",
        )

    subprocess.run(["make", "html"], cwd="doc", check=True)

    env = os.environ.copy()
    env.update({"PYTHONPATH": "."})

    from baselayer.app.app_server import handlers as baselayer_handlers
    from skyportal.app_server import skyportal_handlers
    from skyportal import openapi

    spec = openapi.spec_from_handlers(
        baselayer_handlers + skyportal_handlers,
        metadata={
            "title": "Fritz: SkyPortal API",
            "servers": [{"url": "https://fritz.science"}],
        },
    )
    with open("skyportal/openapi.json", "w") as f:
        json.dump(spec.to_dict(), f)

    subprocess.run(
        [
            "npx",
            "redoc-cli@0.9.8",
            "bundle",
            "openapi.json",
            "--title",
            "Fritz API docs",
            "--cdn",
            "--options.theme.logo.gutter",
            "2rem",
            "-o",
            "../doc/_build/html/api.html",
        ],
        check=True,
        cwd="skyportal",
    )
    os.remove("skyportal/openapi.json")

    if args.upload:
        subprocess.run(
            [
                "./tools/push_dir_to_repo.py",
                "--branch",
                "master",
                "--committer",
                "fritz",
                "--email",
                "fritz@fritz-marshal.org",
                "--message",
                "Update website",
                "--force",
                "./doc/_build/html",
                "git@github.com:fritz-marshal/doc",
            ],
            check=True,
        )


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title="commands", dest="command")

    parent_parser = argparse.ArgumentParser(add_help=False)
    parent_parser.add_argument(
        "--yes", action="store_true", help="Answer yes for all questions"
    )

    commands = [
        ("run", "🚀 Launch Fritz"),
        ("stop", "✋ Shut Fritz down"),
        ("update", "Update Fritz"),
        ("build", "Build Fritz"),
        ("test", "Run the test suite"),
        ("develop", "Install tools for developing Fritz"),
        ("lint", "Lint the full code base"),
        ("prune", "☠️ Wipe out containers, volumes, and submodules"),
        ("doc", "Build the documentation"),
        ("help", "Print this message"),
    ]

    parsers = {}
    for (cmd, desc) in commands:
        parsers[cmd] = subparsers.add_parser(cmd, help=desc, parents=[parent_parser])

    p_run = parsers["run"]
    p_run.add_argument("--init", action="store_true", help="Initialize Fritz")
    p_run.add_argument(
        "--repo",
        type=str,
        default="origin",
        help="Remote repository to pull from at init",
    )
    p_run.add_argument(
        "--branch",
        type=str,
        default="master",
        help="Branch on the remote repository at init",
    )
    p_run.add_argument("--dev", action="store_true", help="Run Fritz in dev mode")
    p_run.add_argument(
        "--traefik", action="store_true", help="Run Fritz behind Traefik"
    )
    p_run.add_argument(
        "--no-kowalski", action="store_true", help="Do not build images for Kowalski"
    )
    p_run.add_argument(
        "--skyportal-tag",
        default="skyportal/web:latest",
        help="Tag to apply to SkyPortal docker image",
    )

    p_build = parsers["build"]
    p_build.add_argument(
        "--init", action="store_true", help="Initialize before building Fritz"
    )
    p_build.add_argument(
        "--repo", type=str, default="origin", help="Remote repository to pull from"
    )
    p_build.add_argument(
        "--branch", type=str, default="master", help="Branch on the remote repository"
    )
    p_build.add_argument(
        "--dev", action="store_true", help="Build Fritz for running in dev mode"
    )
    p_build.add_argument(
        "--traefik", action="store_true", help="Build Fritz to run behind Traefik"
    )
    p_build.add_argument(
        "--no-kowalski", action="store_true", help="Do not build images for Kowalski"
    )
    p_build.add_argument(
        "--skyportal-tag",
        default="skyportal/web:latest",
        help="Tag to apply to SkyPortal docker image",
    )

    p_update = parsers["update"]
    p_update.add_argument(
        "--init", action="store_true", help="Initialize before updating Fritz"
    )
    p_update.add_argument(
        "--repo", type=str, default="origin", help="Remote repository to pull from"
    )
    p_update.add_argument(
        "--branch", type=str, default="master", help="Branch on the remote repository"
    )

    parsers["doc"].add_argument(
        "--upload", action="store_true", help="Upload documentation to GitHub"
    )

    args = parser.parse_args()
    if args.command is None or args.command == "help":
        parser.print_help()
    else:
        getattr(sys.modules[__name__], args.command)(args)
